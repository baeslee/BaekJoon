# 문제 목표
N x M 미로에서 (1,1) -> (N,M) 까지의 이동 수 출력

---
# 입력
라인 1.  

    N (미로 행)  
    M (미로 열)   
    
라인 2 ~ N+1.  

  미로 배열  
  
---
# 출력
라인 1.  

    이동 수  
  
---
# 조건
2 ≤ N, M ≤ 100  
1초  
192 MB  

---
# 주의점
1. 시작점부터 이동 수 = 1 이다.  
2. visit  안 쓴다. -> 빨리 도착하면 어차피 최단일까?  
---
# 동작 순서
1. 입력받기  
2. 큐에 시작점(1,1) 넣기
3. BFS 시작  
  3-1.
   ```
   node = pop()
   dy, dy
   for(4)
   {
     if(cost[row][col] + 1 < cost[cr][cc])
       push(cr, cc)
   }
   ```
5. cost[N][M] 출력  
---
# 변수
int map[N+2][M+2]  
int cost[N+2][M+2]  
Node {row, col}  
int front, rear  
Node list[40000]  
int N, M  

---
# 바꾼점
cost에 전체 값에 높은 값을 다 주면서 초기화하려 했으나 오래 걸릴 것 같아서, 0 또는 높은 값일 경우에 바꾸도록 조건을 바꾸었다.

---
# 놓친점
1. while 조건으로 map 0, 1 적용하는 걸 깜빡함.
